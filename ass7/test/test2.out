* FUNCTION gcd
42: ST 3,-1(1) Store return address.
* COMPOUND
* IF
43: LD 3,-3(1) Load variable v
44: ST 3,-4(1) Save left side
45: LDC 3,0(6) Load constant
46: LD 4,-4(1) Load left into ac1
47: TEQ 3,4,3 Op ==
* THEN
* RETURN
49: LD 3,-2(1) Load variable u
50: LDA 2,0(3) Copy result to rt register
51: LD 3,-1(1) Load return address
52: LD 1,0(1) Adjust fp
53: LDA 7,0(3) Return
48: JZR 3,6(7) Jump around the THEN if false [backpatch]
* ELSE
* RETURN
* Begin call to gcd
55: ST 1,-4(1) Store old fp in ghost frame
* Load param 1
56: LD 3,-3(1) Load variable v
57: ST 3,-6(1) Store parameter
* Load param 2
58: LD 3,-2(1) Load variable u
59: ST 3,-7(1) Save left side
60: LD 3,-2(1) Load variable u
61: ST 3,-8(1) Save left side
62: LD 3,-3(1) Load variable v
63: LD 4,-8(1) Load left into ac1
64: DIV 3,4,3 Op /
65: ST 3,-8(1) Save left side
66: LD 3,-3(1) Load variable v
67: LD 4,-8(1) Load left into ac1
68: MUL 3,4,3 Op *
69: LD 4,-7(1) Load left into ac1
70: SUB 3,4,3 Op -
71: ST 3,-7(1) Store parameter
* Jump to gcd
72: LDA 1,-4(1) Load address of new frame
73: LDA 3,1(7) Return address in ac
74: LDA 7,-33(7) CALL gcd
75: LDA 3,0(2) Save the result in ac
* End call to gcd
76: LDA 2,0(3) Copy result to rt register
77: LD 3,-1(1) Load return address
17
78: LD 1,0(1) Adjust fp
79: LDA 7,0(3) Return
54: LDA 7,25(7) Jump around the ELSE [backpatch]
* ENDIF
* END COMPOUND
* Add standard closing in case there is no return statement
80: LDC 2,0(6) Set return value to 0
81: LD 3,-1(1) Load return address
82: LD 1,0(1) Adjust fp
83: LDA 7,0(3) Return
* END FUNCTION gcd
* FUNCTION main
84: ST 3,-1(1) Store return address.
* COMPOUND
* EXPRESSION
* Begin call to input
85: ST 1,-5(1) Store old fp in ghost frame
* Jump to input
86: LDA 1,-5(1) Load address of new frame
87: LDA 3,1(7) Return address in ac
88: LDA 7,-88(7) CALL input
89: LDA 3,0(2) Save the result in ac
* End call to input
90: ST 3,-2(1) Store variable x
* EXPRESSION
* Begin call to input
91: ST 1,-5(1) Store old fp in ghost frame
* Jump to input
92: LDA 1,-5(1) Load address of new frame
93: LDA 3,1(7) Return address in ac
94: LDA 7,-94(7) CALL input
95: LDA 3,0(2) Save the result in ac
* End call to input
96: ST 3,-3(1) Store variable y
* EXPRESSION
* Begin call to gcd
97: ST 1,-5(1) Store old fp in ghost frame
* Load param 1
98: LD 3,-2(1) Load variable x
99: ST 3,-7(1) Store parameter
* Load param 2
100: LD 3,-3(1) Load variable y
101: ST 3,-8(1) Store parameter
* Jump to gcd
102: LDA 1,-5(1) Load address of new frame
103: LDA 3,1(7) Return address in ac
104: LDA 7,-63(7) CALL gcd
105: LDA 3,0(2) Save the result in ac
* End call to gcd
106: ST 3,-4(1) Store variable result
* EXPRESSION
* Begin call to output
107: ST 1,-5(1) Store old fp in ghost frame
* Load param 1
18
108: LD 3,-4(1) Load variable result
109: ST 3,-7(1) Store parameter
* Jump to output
110: LDA 1,-5(1) Load address of new frame
111: LDA 3,1(7) Return address in ac
112: LDA 7,-107(7) CALL output
113: LDA 3,0(2) Save the result in ac
* End call to output
* EXPRESSION
* Begin call to outnl
114: ST 1,-5(1) Store old fp in ghost frame
* Jump to outnl
115: LDA 1,-5(1) Load address of new frame
116: LDA 3,1(7) Return address in ac
117: LDA 7,-81(7) CALL outnl
118: LDA 3,0(2) Save the result in ac
* End call to outnl
* END COMPOUND
* Add standard closing in case there is no return statement
119: LDC 2,0(6) Set return value to 0
120: LD 3,-1(1) Load return address
121: LD 1,0(1) Adjust fp
122: LDA 7,0(3) Return
* END FUNCTION main
0: LDA 7,122(7) Jump to init [backpatch]
* INIT
123: LD 0,0(0) Set the global pointer
* INIT GLOBALS AND STATICS
* END INIT GLOBALS AND STATICS
124: LDA 1,0(0) set first frame at end of globals
125: ST 1,0(1) store old fp (point to self)
126: LDA 3,1(7) Return address in ac
127: LDA 7,-44(7) Jump to main
128: HALT 0,0,0 DONE!
* END INIT
